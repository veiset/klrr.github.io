<!DOCTYPE HTML>
<html><meta charset="utf-8"><head><title>klrr&#39;s blog</title><link rel="stylesheet" type="text/css" href="../../css/style.css"><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif|Oleo+Script:700"></head><body><h1 class="fronttitle">klrr&#39;s blog</h1><p class="menu"><a href="../../archive/">posts</a> · <a href="https://github.com/klrr">code</a> · <a href="../../about/">me</a></p><h1 id="vigorous-functions">Vigorous functions</h1>
<p>I've recently started reading <a href="http://www.cis.upenn.edu/~bcpierce/tapl/">TAPL</a> and it litterally blew my mind away. Before I tell what exactly blow my mind away let me start by telling a little story. A while back I implemented a Lisp interpreter after reading a tutorial, it amazed me how little code could actually produce a programming language. What amazed me even more was how few primitives was actually needed to create a very powerful one. I thought a lot about how I could remove even more primitives while retaining this power, more precisely how to remove conditionals as a special form. I failed and moved on. In the beginning of TAPL they showed how to program in lambda calculus. Their first example was <em>how to implement this exact thing</em>.</p>
<p>So, what's so amazing with implementing conditionals? Well, lambda calculus is an extremely simple language that <em>only</em> consists of functions. First-class anonymous functions who only take one argument to be precise. &quot;First-class&quot; means they are treated as any other value and &quot;anonymous&quot; means they're not bound to a name. Let me show how to implement conditionals and some boolean logic operations using only this concept of functions. I'll use Scheme since it allows to demonstrate this without teaching lambda calculus (if you're not familiar with it I suggest <a href="http://mitpress.mit.edu/sicp/">SICP</a> as a good introduction to the language, you'll only need to know the very basics for reading the code below).</p>
<pre><code>(define tru (lambda (t f) t))
(define fls (lambda (t f) f))

(define test (lambda (b x y) (b x y)))

(define and (lambda (a b) (a b fls)))
(define or  (lambda (a b) (a tru b)))

(define not (lambda (b) (b fls tru)))</code></pre>
<p>We represent true and false as functions, and use these as a base for the rest of the operations. Lets try these out in the repl.</p>
<pre><code>&gt; (test (or (not tru) fls) 1 2)
2</code></pre>
<p>In fact, we don't even need the primitive numbers from Scheme, we can represent them as functions as well. We can even do recursion without using the ability to define functions directly with <code>define</code> (e.g. <code>(define (length l) (if (null? l) 0 (+ 1 (length (cdr l)))))</code>). What you use instead then would be a so called fixed-point combinator such as the Y combinator. First-class anonymous functions (together with application) is <em>turing complete</em>, meaning it can in principle solve any computational problem.</p>
<p>So what I wanted to say with this little article is; functions are very powerful.</p><footer>(C) 2014 Karl-Oskar Rikås</footer></body></html>